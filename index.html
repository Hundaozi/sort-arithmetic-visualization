<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>排序算法动画</title>
    <link rel="stylesheet" type="text/css" href="css/main.css">
</head>

<body oncontextmenu="return false;" onselectstart="return false">
    <div class="nav">
        
        <div class="sort">选择排序
            <!-- <span class="line line-top"></span> -->
            <!-- <span class="line line-left"></span>
                <span class="line line-right"></span>
                <span class="line line-bottom"></span> -->
        </div>
        <div class="sort">冒泡排序</div>
        <div class="sort">快速排序</div>
        <div class="sort">归并排序</div>
        <div class="sort">插入排序</div>
        <div class="sort">希尔排序</div>
    </div>
    <div id="container1">
    </div>
    <div id="container2">
        <div id="container3"></div>
        <div id="container4"></div>
    </div>

            
    
    <div id="controller">
        <input type="text" id="array" name="">
        <div class="button" id="random">随机</div>
        <div class="button" id="prev">上一步</div>
        <div class="button" id="startAndPause">开始</div>
        <div class="button" id="next">下一步</div>
        <div id="progressBar"><div class="slider"></div>速度</div>
        <div id="speedBar"></div>
    </div>
    <div id="explain">
        <div>
            <p>选择排序基本思想比较简单， 在待排序的序列中， 先选出最小的一个元素， 将其与第 1 个位置的元素交换； 然 后在剩下的元素当中找最小的元素， 与第 2 个位置的元素交 换， ……， 直到第 n-1 个元素和第 n 个元素 （最后一个数） 比较为止。 通过对简单选择排序算法的分析， 在简单选择排序过程 中， 对一个序列， 无论它的初始状态如何， 元素间的关键字 比较次数是相同的， 均为 次。 但若序列的初始状态是 正序的， 那么它的元素移动次数最小， 最小值为 “0” 次； 反 之， 移动次数最大， 最大值为 3 （n-1） 次。 所以， 简单选择 排序的时间复杂度为O (n2)。 </p>
        </div>
        <div>
            <p>冒泡排序是计算机排序算法中最基本， 也是最经典的一 种算法。 它的排序过程很简单， 一次比较两个元素， 依次比 较两个相邻的元素， 首先比较第一个和第二个元素， 如果顺 序错误， 则进行交换， 然后比较第二个和第三个元素； 依次 类推， 直至最后两个元素， 即第 n-1 个元素和第 n 个元素比 较过为止， 这一过程称为第一趟排序； 然后再进行第二趟排 序， 即对第一个元素到第n-1 个元素重复第一趟排序操作； 接着进行第三趟、 第四趟、 ……、 第 N 趟排序。 从排序过程 中可以看出， 关键字越小的元素会经由交换慢慢 “浮” 到数 列的顶端， 关键字越大的元素会慢慢地 “沉入” 数列的最底 端。 所以， 这个排序算法称为 “冒泡排序”。 </p>
        </div>
        <div>
            <p>快速排序是对冒泡排序的一种改进， 它的基本思想是选 择一个基准元素， 经过一趟排序操作后， 把待排序列分成两 个独立的部分， 一部分的关键字比基准元素的小， 另一部分 的关键字比基准元素的大， 这样基准元素就找准了自己的位 置， 然后再继续对这两个独立的部分分别用上面的方法继续 进行分割排序， 直到整个序列有序为止。 快速排序的排序过程： 对于一个无序的序列， 首先设置 两个指针 Low 和 High， 分别指向无序的序列的第1 个元素 和第 n 个元素。 先从 High 所指位置向前逐个与基准的关键 字进行比较， 找的第一个关键字小于基准元素的关键字， 将 其与基准元素进行交换， 接着再从 Low 所指元素位置， 向后 搜索比较， 找到第一个关键字比基准大的元素， 将其与基准 元素交换， ……， 重复这两步操作， 直到 Low 与 High 重复 为止。 根据快速排序的基本思想可知， 每次排序是从无序的序 列中找出一个元素作为基准， 然后把小于基准的元素放在基 准的左边， 把大于基准的元素放在基准的右边； 对以上过程， 需要重复 「log2 n」 趟得到有序的序列。 并且快速排序每趟需 对 n 个元素进行一次处理， 所以他的时间复杂度为 O (nlogn)。 快速排序是不稳定的。 </p>
        </div>
        <div>
            <p>归并排序的基本思想是将两个或两个以上的有序序列合 并成一个新的有序序列。 它的排序过程为： 设初始序列由 n 个元素组成， 第一步看成是 n 个有序的子序列， 每个子序列 的长度为 1， 然后两两合并， 得到 个长度为 2 或 1 的有序子 序列， 然后再重复上述操作， 直到得到一个长度为n 的有序 序列为止。 这种归并方法称为2-路归并排序。 对归并算法分析可得， 整个归并排序需要进行 「log2 n」 趟， 在一趟归并排序中， 对于前后相邻的长度为h 的子序列， 需要进行 次两两合并， 得到一个长度为 2h 的新的有序序 列， 所以， 归并排序的时间复杂度为O(nlogn)。</p>
        </div>
        <div>
            <p>直接插入排序是一种比较好理解的排序算法， 它的基 本思想是取一个元素， 将这个元素插入到已经有序的序列 中， 从而就可以得到一条新的、 元素总数加 1 的有序序列。 它的排序过程： 对于一个无序的序列， 先取序列的第 1 个 元素为一个有序的子序列， 然后把第 2 个元素插入到合适 位置， 接着将第 3 个元素插入到合适位置， 直至所有元素 都在合适位置为止。 在排序过程中， 为了防止数组越界， 可以在第 0 个元素处设置监视哨， 将每次要插入的元素设 为哨兵。 对于直接插入排序算法， 若序列的初始状态是正序的，那么第 i 趟只比较了第 i 个元素与第 i-1 个元素一次， 因此， 正序序列总共比较了n-1 次， 并且由于第 i 个元素的关键字总 是比第 i-1 个元素的关键字大， 因此没有移动记录； 但当最坏 情况， 即序列是逆序时， 此时需要比较 次， 元素移动次数也是最大值 次。 所以， 直 接插入排序的时间复杂度为O (n2)。 </p>
        </div>
        <div>
            <p>希尔排序又被叫做缩小增量排序， 它是直接插入排序的 一种改进， 是在 1959 年， 由 D.L.Shell 提出来的， 对比直接插 入排序， 在时间效率上有较大改进。 它的基本思想是先选取 一个增量， 根据这个增量将整个待排序的序列分割成若干子 序列， 然后再对这些子序列分别进行直接插入排序， 待整个 序列中的元素 “基本有序” 时， 再对全体元素进行直接插入 排序。 其中， 这些子序列的分割不是简单的 “逐段分割”， 而 是选取相隔某个 “增量” 的元素作为一个子序列。 这样， 关 键字较小的元素就不是像直接插入排序那样一步一步地慢慢 向前移动， 而是按照 “增量”， 向前跳跃式前进。 所以， 希尔 排序的时间复杂度要比直接插入排序低。 希尔排序的效率分析是一个复杂的问题， 这主要由于它 的时间复杂度由增量序列的选取有关， 涉及到目前数学上一 些尚未解决的难题[1]。 </p>
        </div>
    </div>
    <script src="js/lib/jquery-3.1.1.js"></script>
    <script src="js/sort.js"></script>
    <script src="js/animate.js"></script>
    <script src="js/frames.js"></script>
    <script src="js/main.js"></script>
    <script type="text/javascript">
    </script>
</body>

</html>
